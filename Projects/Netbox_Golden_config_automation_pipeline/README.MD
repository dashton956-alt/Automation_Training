 PROJECT 1 â€” NetBox â†’ Golden Config Automation Pipeline
A slow, guided walkthrough for beginners â†’ intermediate â†’ advanced.

ğŸ§  Step 0 â€” What this project actually is
You are building a pipeline that:


Pulls data from NetBox
(hostname, interfaces, VLANs, IPs, BGP ASN, device role, etc.)


Feeds that data into Jinja2 templates
(spine/leaf configs for cEOS + SRL)


Uses Nornir to run a DRYâ€‘RUN diff
(see what would change)


Optionally deploys the config to your lab


Runs GitHub Actions CI
(lint the code, test Jinja templates, and generate configs automatically)


This is exactly how real automation teams build pipelines.

ğŸ§© Step 1 â€” The Minimum You Need
This project can be built incrementally.
Hereâ€™s the minimum starting toolkit:
Tools

Python
NetBox running locally or remote
uv (your package manager)
Git + GitHub repo
Nornir (later)

Python libraries
Start with only:
httpx
pydantic
jinja2

Later youâ€™ll add:
nornir
nornir-napalm
nornir-utils

Don't install everything at once â€” we build layer-by-layer.

ğŸ” Step 2 â€” Understand the Flow Before Coding
Think of this as a 3â€‘stage pipeline:
[ NetBox ] â†’ [ Python Data Model ] â†’ [ Jinja Template ] â†’ [ Config Output ]

Letâ€™s break this down slowly.

ğŸ§± Step 3 â€” NetBox â†’ Python (reading inventory)
Why this matters
Your templates must be driven by a SoT â€” no hardcoding.
What you do
You write a tiny Python script that:

Connects to NetBox
Asks for a single device
Prints the JSON

Example (NOT code yet, just logic):
GET /api/dcim/devices/?name=srl-leaf-01
GET /api/ipam/ip-addresses/?device_id=<id>
GET /api/dcim/interfaces/?device_id=<id>

Goal of this step
Get comfortable with NetBox API and the shape of the data.

ğŸ§± Step 4 â€” Turn NetBox JSON into â€œcleanâ€ Python data
Raw API JSON is messy.
You want a clean object like this:
Device:
  hostname: "srl-leaf-01"
  mgmt_ip: "10.10.10.3/32"
  role: "leaf"
  asn: 65011
  interfaces:
    - name: ethernet-1/1
      ip: 10.1.1.1/31
      vlan: 100

This is where Pydantic comes in.
Why Pydantic?

Validates missing fields
Ensures types (string, int, list)
Gives your Jinja templates predictable data

Goal of this step
Create a reliable â€œdevice modelâ€ class.

ğŸ§± Step 5 â€” Build Your First Jinja2 Template
Donâ€™t build everything at once.
Start simple. Example template:
hostname {{ device.hostname }}
!
interface mgmt0
  ip address {{ device.mgmt_ip }}
!

Baby step goal
Render a config file into:
output/spine01.cfg

If you can do this, you can build the whole project.

ğŸ§± Step 6 â€” Add More Template Complexity (Slowly)
Add building blocks one at a time:

Loop over interfaces
Add BGP
Add VLANs
Add OSPF/ISIS (if your lab uses them)

Example interface loop:
{% for interface in device.interfaces %}
interface {{ interface.name }}
  description {{ interface.description }}
  ip address {{ interface.ip }}
{% endfor %}

Goal
Be comfortable feeding structured data â†’ Jinja template.

ğŸ§± Step 7 â€” Automate Rendering for ALL Devices
Your script evolves:
for device in netbox.get_all_devices():
    model = DeviceModel(**device_json)
    config = render_template(model)
    save_config(device.hostname + ".cfg")

This produces a Golden Config Bundle.

ğŸ§± Step 8 â€” Introduce Nornir (Dry-Run First)
Now you add Nornir to:

load an inventory generated from NetBox
SSH to devices
run â€œdiffâ€ checks
ensure config matches what you expect

Important:
Start with NAPALM "compare_config".
This shows diffs without making changes.

ğŸ§± Step 9 â€” Add GitHub Actions CI
Add automation:

Every push to main:

lint Python (ruff)
test Jinja rendering (pytest)
build configs (python generate_configs.py)
upload produced configs as artifacts




ğŸ§± Step 10 â€” Optional Advanced Features
You can add these later:
â­ Validation (GAIT-Style)
Check naming, VLAN ranges, IP format.
â­ Multi-vendor support
cEOS, SRL, EOS, Cisco, Juniper.
â­ Config Deployment
Let Nornir push configs only when validated.
â­ Change Reports
Generate HTML summaries of diffs.

ğŸ§© Summary: Your Slow-Burn Learning Path
Here is the step-by-step order I recommend while learning:
1. Query NetBox (print JSON)
2. Build Pydantic model
3. Build simple Jinja2 config
4. Render config for one device
5. Render configs for all devices
6. Add interfaces â†’ routing â†’ VLANs
7. Add Nornir dry-run
8. Add Nornir deploy
9. Add GitHub CI

Each step builds on the last â€” no overwhelm.